# Список вопросов к экзамену в рамках курса "Введение в распределенные технологии 2022/2023"

На экзамене 12.01.23 отвечал на вопросы # [9](#question_9) и [23](#question_24) (24 в моей нумерации, преподаватель пропустил вопрос).

## Виртуализация и контейнеризация

### 1. Что такое виртуализация? Какие виды бывают, чем виртуализация отличается от контейнеризации и отличается ли?
Эти вопросы разобраны в моей [технической статье](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/containerd_medium_paper/conainerd_medium_paper.md) в главе **Функции ядра Linux и контейнеры**, в параграфе **Виртуальные машины vs Контейнеры**.

**Виртуализация** - это построение вычислительной среды, в которой на базе одних и тех же аппаратных ресурсов работает множество изолированных друг от друга виртуальных машин.

**Виртуальная машина** - это программа, которая эмулирует (имитирует) работу другой программы.

> Главная идея виртуализации - оптимизация расходывания вычислительных ресурсов.

* [Виртуальная машина (Yandex Cloud)](https://cloud.yandex.ru/docs/glossary/vm)
* [Что такое виртуализация? (Yandex Cloud)](https://cloud.yandex.ru/docs/glossary/virtualization)

---
### 2. Что такое docker, rkt, containerd? Как работает контейнеризация в одной из выбранных систем на выбор? (Полное объяснение с работой сетей и т.д)
**Docker** - платформа контейнеризации, архитектура описана во [второй лекции](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/lectures.md).

**rkt (Rocket)** - аналог Docker (на данный момент проект закрыт).

**containerd** - высокоуровневая среда выполнения контейнеров. Подробное описание работы контейнеризации и связь containerd с Docker и Kubernetes есть в моей [технической статье](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/containerd_medium_paper/conainerd_medium_paper.md).

[Обзор](https://docs.docker.com/network/) сетевого взаимодействия в Docker из официальной документации. Также отмечу полезную [статью](https://itisgood.ru/2019/10/29/objasnenie-koncepcii-setej-v-docker/) и [видеолекцию](https://www.youtube.com/watch?v=ctJnI43ermQ).

В Docker существуют различные типы сетей, которые подключаются с помощью соответствующих **драйверов (network drivers)**:

* **bridge** - сеть по-умолчанию, позволяет связать несколько контейнеров **на одном host'е**.
    * Сеть видна/доступна на host'е (главном компьютере) под именем **docker0**
    * Когда контейнеры запускаются и подключаются к мостовым сетям, создается **пара сетевых сокетов**:
        * Один присваивается контейнеру как **eth0**
        * А другой присваивается/подключается к мосту как **vethX**, где X - случайная строка
    * Контейнер наследует настройку DNS демона docker (от host'а)
    * В этой сети нет технологии **обнаружения сервисов (Service Discovery)**
        * Однако при создании **пользовательской (user-defined)** мостовой сети обнаружение сервисов будет
    
* **host** - позволяет контейнеру совместно использовать сетевое пространство имен host'а.
    * **Удаляется сетевая изоляция** между контейнером и host'ом 
    * Если запустить контейнер, который привязывается к порту 80, и использует host-сеть, то приложение контейнера доступно через порт 80 по IP-адресу host'а
        * Это значит, что вы не сможете запускать несколько контейнеров на одном host'е, на одном и том же порту, так как порт теперь является общим для всех контейнеров в сети host'а
    * Контейнеру не выделяется IP-адрес, он совместно использует его с host'ом (то есть **не создается пара сокетов**)
    * Полезно для **оптимизации производительности**, так как **не требуется NAT** между host'ом и контейнером. Никакой "пользовательский прокси-сервер" не создается для каждого порта контейнера
        * NAT (англ. Network Address Translation) - преобразование сетевых адресов. Предназначен для упрощения и сохранения IP-адресов. [Nat на пальцах: что это?](https://wiki.merionet.ru/seti/13/nat-na-palcax-chto-eto/)
    * Сеть host'a работает только на host'ах **Linux**

* **none (null)** - в сети такого типа контейнеры не подключены ни к одной сети и не имеют доступа к внешней сети или другим контейнерам.
    * Полезно, когда требуется полностью отключить сетевой стек в контейнере

* **overlay** - этот драйвер позволяет строить сети **на нескольких host'ах** с Docker (обычно на Docker Swarm кластере) с помощью инкапсуляции пакетов.
    * Драйвер cоздает внутреннюю частную сеть, которая охватывает все узлы, участвующие в кластере swarm.

* **macvlan** - позволяет назначить MAC-адрес контейнеру, чтобы он отображался как физическое устройство в сети.
    * Docker-демон будет направлять трафик в контейнеры по их MAC-адресам
    * Использование драйвера macvlan целесообразно при работе с устаревшими приложениями, которые ожидают прямого подключения к физической сети, а не маршрутизации через сетевой стек узла Docker
    * Полезно, при переходе с виртуальной машины или когда, нужно,чтобы контейнеры выглядели как физические узлы в сети, каждый с уникальным MAC-адресом

* **Network plugins** - сторонние плагины позволяют интегрировать Docker со специализированными сетевыми стеками.

* **ipvlan** - предоставляет пользователям полный контроль над IPv4 и IPv6-адресацией.

С помощью команды `docker network ls` можно вывести список сетей по умолчанию, их будет три:
* none
* host
* bridge

Сети по умолчанию подробно описаны в статье: [Docker Networking Deep Dive](https://github.com/KamranAzeem/learn-docker/blob/master/docs/docker-networking-deep-dive.md).

Остальные сетевык команды docker можно посмотреть командой: `docker network --help`.

Наиболее часто используют **Bridge** и **Overlay** сети, они хорошо описаны [здесь](https://habr.com/ru/company/flant/blog/521406/):

* Контейнеры на **одном** host'е можно связать **Linux-мостом (Bridge network)**, для этого необходимо создать **виртуальные устройства** [veth (virtual ethernet device)](https://man7.org/linux/man-pages/man4/veth.4.html). Один конец veth-устройства подключается к сетевому пространству имен контейнера, другой - к Linux-мосту в сети host'а. У всех контейнеров на одном host'е один из концов veth подключен к мосту, через который они могут связываться друг с другом по IP-адресам.
    * **У Linux-моста также имеется IP-адрес**, и он выступает в качестве шлюза для исходящего (egress) трафика из Pod'ов, предназначенного для других узлов.

* Контейнеры на **разных** host'ах можно связать по IP-адресам с помощью **инкапсуляции пакетов (Overlay network)**. Во Flannel за эту возможность отвечает технология [vxlan](https://vincent.bernat.ch/en/blog/2017-vxlan-linux), которая «упаковывает» исходный пакет в пакет **UDP** и затем отправляет его по назначению.
    * Полезно, когда нам **не хватает пространства IP-адресов** или сеть не может управлять дополнительными маршрутами. Или когда мы хотим получить **дополнительные возможности управления**, предоставляемые оверлеями.
    * Инкапсуляция-декапсуляция всех пакетов добавляет небольшую **задержку** и **сложность**

IPTables rules

---
### 3. Что такое kubernetes? Архитектура, работа служебных сервисов, методы организации развертывания контейнеров
**Kubernetes** - это платформа оркестрации контейнеров для автоматизации развертывания, масштабирования и управления контейнерными приложениями. Задача Kubernetes заключается в **координации кластера** компьютеров, работающего как **одно целое**. Абстрактные объекты в Kubernetes позволяют развертывать контейнеризированные приложения в кластер, не привязывая их к отдельным машинам.

**Архитектура** Kubernetes подробно разобрана во [второй](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/lectures.md) лекции. Кроме того, рекомендую данную [статью](https://habr.com/ru/company/flant/blog/583660/).

> Kubernetes — это всего лишь пять бинарников.

* **Control Plane** - предоставляет API и интерфейсы для определения, развертывания и управления жизненным циклом контейнеров.
    * kube-apiserver - предоставляет Kubernetes API
* **Node** - это рабочая машина в Kubernetes.

* Kubernetes позволяет приложениям абстрагироваться от инфраструктуры, давая нам простое API, к которому можно отправлять запросы.
* Kubernetes способствует стандартизации работы с провайдерами облачных услуг (Cloud Service Provider, CSP).

Работа **служебных сервисов** описана в моей [статье](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/containerd_medium_paper/conainerd_medium_paper.md).

**Container Runtime Interface (CRI)** определяет API между Kubernetes и Container Runtime. Данный стандарт позволил Kubernetes не интегрироваться с Docker, а использовать среды выполнения напрямую, если они соответствуют спецификации.

**Container Networking Interface (CNI)** - набор требований к исполняемой среде контейнеров (container runtimes) и плагинам (plugins), соответствие которым позволяет любому плагину работать с любым runtime'ом.

**Развертывание** Kubernetes-кластеров подробно разобрано в [пятой](https://github.com/AnatoliyBr/2022_2023-introduction_to_distributed_technologies-k4111c-briushinin_a_a/blob/master/lectures.md) лекции.

* **On-premise (на железе)** - вам предоставляется ВМ и вы руками что-то устанавливаете на конкретные компьютеры.
    * kubeadm, kubectl, kubelet, CRI 
    * Для быстрого развертывания использовать систему для удаленного управления конфигурациями Ansible
* **Cloud (в облаке)** - компания предоставляет услугу по выделенным вычислениям, которые выполняются на их инфраструктуре.
    * GCP

---
### 4. Что такое Pod, Deployment - основные понятия, виды ресурсов + манифесты для каждого типа ресурсов
**Pod** - минимальная развертываемая единица в K8S, набор из одного и более контейнеров, имеющих общее пространство имен и тома общей файловой системы.

Надо отметить, что контейнеры имеют собственные **изолированные** файловые системы, но они могут **совместно** использовать данные, пользуясь ресурсом K8S, который называется **Volume (том)**.

Важным архитектурным принципом сетевого устройства Kubernetes является то, что каждый Pod обладает уникальным IP-адресом. **IP Pod'а делится между всеми его контейнерами** и является доступным (маршрутизируемым) для всех остальных Pod'ов.

Для описания пода пишут **манифест (manifest file)**, шаблон которого есть в документации.

Для создания корректного описания манифеста в **YAML-формате** достаточно знать только два типа структур:
* списки (lists)
* мапы (maps)

Шаблон манифеста Pod'а:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: vault
  labels:
    app: lab1
spec:
  containers:
    - name: vault
      image: vault
      ports:
        - containerPort: 8200
```

Что важно:
1. Задать тип ресурса (`kind: Pod`)
2. Задать имя ресурса в metadata (`name: vault`)
3. Добавить метку в metadata (`app: lab1`)
4. Задать имя контейнера, образ, порт (`name`, `image`, `ports`)

**Deployment** - ресурс K8S, который позволяет автоматизировать процесс перехода от одной версии приложения к другой без прерывания работы системы. В нем описывается **желаемое** состояние системы. Deploymnet предоставляет декларативные обновления для Pod'ов и ReplicaSet'ов.

Отвечает за:
* Поддержание системы в нужном состоянии (например, если мы удалим из развертывания 1 Pod, K8S запустет другой)
* Выполнение развёртываний с нулевым временем простоя системы
* Откат к предыдущему состоянию системы

На самом деле Deployment относится к такому виду ресурсов K8S как **Controller**, которых существует 5 типов:
* ReplicaSet - поддерживает определенное число Pod'ов в системе
* Deployment - на самом деле это контроллер контроллера ReplicaSet, который отслеживает количество реплик, контроллер Deployment расширяет этот функционал
* DaemonSet - поддерживает по одной реплике Pod на каждой из Node кластера
* Job - поднимает Pod, отрабатывает и помирает до следующего запуска
* CronJob - Job, который запускается по расписанию

Шаблон манифеста Deployment
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  labels:
    app: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend_pod
  template:
    metadata:
      labels:
        app: frontend_pod
    spec:
      containers:
      - name: frontend-container
        image: ifilyaninitmo/itdt-contained-frontend:master
        ports:
        - containerPort: 3000
        env:
        - name: REACT_APP_USERNAME
          value: Anatolii
        - name: REACT_APP_COMPANY_NAME
          value: ITMO
```

Что важно:
1. Задать тип ресурса (`kind: Deployment`)
2. Задать имя ресурса в metadata (`name: frontend`)
3. Добавить метку в metadata (`app: frontend`)
4. Задать число копий Pod'a в spec (`replicas: 2`), в документации принято обозначать, как поле `.spec.replicas`
5. В поле `.spec.selector.matchLabels` задается по каким метками, созданный ресурс будет находить Pod'ы, которыми он управляет
6. Шаблон Pod'а задается в объекте `template`. С помощью свойства `env` объявляем внутри Pod'ов переменные окружения `REACT_APP_USERNAME` и `REACT_APP_COMPANY_NAME` со значениями `Anatolii` и `ITMO`, соответственно.

---
### 5. Что такое Service и Ingress? - основные понятия, виды ресурсов + манифесты для каждого типа ресурсов

**Service** - это ресурс, который определяет логический набор Pod'ов и политику (правила) доступа к ним (иногда этот шаблон называют микросервисом).

Набор Pod'ов, на которые нацелен сервис определяется selector'ом.

Существует несколько типо сервисов (поле `type`):
* ClusterIP
    * Обеспечивает сервис **внутри кластера** - внешнего доступа нет
    * Тип сервиса по-умолчанию
    * Недостаток: выбор этого сервиса делает Pod доступным только изнутри кластера, т.е. есть риск потерять внешний IP адрес при переезде Pod
* LoadBalancer
    * Позволяет открыть внешний доступ и жестко привязать внешний IP адрес к Pod (например, можно поднять реплику БД со статичным IP адресом)
    * Недостаток: ограниченность IPv4 адресов
* NodePort
    * Открывает на всех Нодах кластера порт, запросы попадающие на этот порт будут перенаправлены в ваш Pod
    * Недостаток: порты доступны в интервале 30000–32767
* ExternalName

Шаблон манифеста Service (типа NodePort)
```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  labels:
    app: lab3-frontend
spec:
  type: NodePort
  selector:
    app: lab3-frontend
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000
      nodePort: 30333
```

Что важно:
1. Задать тип ресурса (`kind: Service`)
2. Задать имя ресурса в metadata (`name: frontend-service`)
3. Добавить метку в metadata (`app: lab3-frontend`)
4. Задать тип сервиса (`type: NodePort`)
5. В поле `.spec.selector` задается метка, определяющая на какие Pod'ы будет нацелен сервис
6. В поле `port` указывается, какой порт прослушивает сервис, а в поле `targetPort` на какой порт он будет перенаправлять трафик
7. В зависимости от типа сервиса настройки портов будут отличаться, в данном случае есть поле `nodePort`, весь трафик, приходящий на него, будет перенаправлен на `targetPort` 

Для удобства в `port` и `targePort` устанавливают одно и то же число.

**Ingress** - ресурс K8S, с помощью которого мы можем задать единую точку входа в кластер. Ingress позволяет нам назначить для каждого сервиса свой [URL](https://ru.wikipedia.org/wiki/URL), доступный вне кластера.

Ingress предоставляет доступ к маршрутам HTTP и HTTPS из-за пределов кластера к сервисам внутри кластера. Маршрутизация трафика контролируется правилами, определенными на Ingress ресурсе.

Чтобы использовать Ingress нужен **Ingress Controller** (например, можно развернуть **ingress-nginx**)

Манифест Ingress
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: frontend-ingress
spec:
  tls:
  - hosts:
      - frontend-lab3.anatolii
    secretName: lab3-tls
  rules:
  - host: frontend-lab3.anatolii
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 3000
```
Что важно:
1. Для Ingress требуются поля `apiVersion`, `kind`, `metadata` и `spec`.
2. Имя Ingress объекта в metadata должно быть допустимым именем поддомена DNS (`name: frontend-ingress`)
3. Пропущено поле `.spec.ingressClassName`, потому что некоторые Ingress controller'ы работают без определения IngressClassName, например **ingress-nginx**
4. В поле `.spec.rules` описываются **правила** (`rules`) маршрутизации трафика:
* `host` - необязательное поле, если host не указан, правило применяется ко всему входящему HTTP-трафику через указанный IP-адрес, иначе правила применяются к этому хосту (как в примере)
    * В полях hosts и host указываем доменное имя (FQDN) - frontend-lab3.anatolii
* Каждый путь `path` имеет `pathType`, всего есть три вида pathType:
    * ImplementationSpecific
    * Exact
    * Prefix
* В поле `backend` указываются сервисы и номера портов
    * HTTP (и HTTPS) запросы к Ingress, которые соответствуют `host` и `path` в правилах (`rules`), отправляются на указанный сервер (backend)

TLS сертификат представляет собой технологию безопасности, с помощью которой шифруется связь между браузером и сервером: сертификат с публичным ключом для шифрования, приватный ключ для расшифровки.

---
### 6. Что такое ConfigMap и Secrets? - основные понятия, виды ресурсов + манифесты для каждого типа ресурсов
Для хранения данных в K8S существует **4 типа** ресурсов:
* **ConfigMap** - это объект API, используемый для хранения **неконфиденциальных** данных в парах ключ-значение.
    * позволяют разделить данные конфигурации и код приложения
    * объем данных не может превышать 1 Мб

Манифест ConfigMap
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-configmap
data:
  react_app_user_name: "Anatolii"
  react_app_company_name: "ITMO"
```

Что важно:
1. Задать тип ресурса (`kind: ConfigMap`)
2. Задать имя ресурса в metadata (`name: frontend-configmap`)
3. Задать данные в поле `.data` можно двумя способами (в примере задано первым - ключ-значение):
* property-like keys
* file-like keys

Через CongigMap можно задать значение переменной окружения Pod'a:
```yaml
env:
- name: REACT_APP_USERNAME
  valueFrom:
    configMapKeyRef:
        name: frontend-configmap
        key: react_app_user_name
- name: REACT_APP_COMPANY_NAME
  valueFrom:
    configMapKeyRef:
        name: frontend-configmap
        key: react_app_company_name

```

* **Secret** - это объект, содержащий небольшое количество **конфиденциальных** данных, таких как пароль, токен или ключ.
    * по сути это те же ConfigMaps только для хранения конфиденциальных данных
    * данные кодируется в base64

Манифест Secret
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  USER_NAME: YWRtaW4=
  PASSWORD: MWYyZDFlMmU2N2Rm
```

Что важно:
1. Задать тип ресурса (`kind: Secret`)
2. Задать имя ресурса в metadata (`name: mysecret`)
3. Задать тип (`type`) секрета - это облегчает программную обработку секретных данных, типов около 8:    
    * Opaque - произвольные пользовательские данные
    * tls - данные для клиента или сервера TLS (как было в лабораторной #3, но там я создавал секрет с помощью команды: `kubectl create secret tls lab3-tls --cert=lab3.crt --key=lab3.key`)
    * и т.д.
4. Задать данные в поле `.data`

* EmptyDir
    * данный том предназначен для хранения небольших данных
    * создается пустым (отсюда и название) на сервере, где лежит Pod в оперативной памяти или на диске
    * существует, пока будет жив его Pod

* Persistent Volume Claim
    * хранение постоянных данных приложений
    * для использования PVC, необходимо, чтобы в кластере был реализован интерфейс CSI (Container Storage Interface) администратором кластера
    * PVC своего рода запрос необходимого постоянного тома (диска)

---
### 7. Как работают CNI, типы CNI, особенности развертывания и эксплуатации
Чтобы разобраться какую роль играет **Интерфейс контейнерной сети (CNI)** в системе, K8S рекомендую прочитать статью [Как pod в Kubernetes получает IP-адрес](https://habr.com/ru/company/flant/blog/521406/).

Проект **CNI** представляет собой **спецификацию** для организации универсального сетевого решения для Linux-контейнеров.

Другими словами, **CNI** - **набор требований** к исполняемой среде контейнеров (container runtimes) и плагинам (plugins), соответствие которым позволяет любому плагину работать с любым runtime'ом.

CNI состоит из 4 частей:
* **Спецификация** - определяет обязательные поддерживаемые операции (добавление и удаление контейнера из сети), список параметров, формат конфигурации сети и их списков.
* **Плагины CNI (CNI plugin)** - это исполняемые файлы, соответствующие спецификации. Существуют плагины, отвечающие за различные функции **при настройке сети** Pod'а. Разбиты на 4 категории:
    * main (loopback, bridge, ptp, vlan, ipvlan, macvlan)
    * ipam (dhcp, host-local)
    * meta (flannel, tuning)
    * sample
* Библиотеки - это реализации спецификации CNI (тоже на языке Go) для удобного использования в исполняемых средах контейнеров.
* Сторонние плагины - обеспечивают поддержку различных современных решений для Linux-контейнеров.
    * **Project Calico** (виртуальная сеть L3)
    * **Weave** (простая сеть для multi-host Docker-инсталляций)
    * **Contiv Netplugin** (политики/ACL/QoS и другие возможности для контейнеров в кластерных установках типа multi-host)
    * **Flannel** (сетевая фабрика для контейнеров от CoreOS)
    * SR-IOV, Cilium (BPF/XDP), Multus (плагин Multi для Kubernetes от Intel), VMware NSX

CNI, который используется в Minikube по-умолчанию, не поддерживает никакую NetworkPolicy, поэтому необходимо установить другую CNI - **Calico**.

**Calico** является **сетевым "провайдером"**, который обеспечивает каждому Pod'у в кластере свой IP.

У каждого сетевого провайдера имеется свой **CNI plugin**.

> Runtime контейнера запускает CNI plugin, чтобы **сконфигурировать сеть** для Pod'a в процессе его запуска.

При этом у каждого провайдера есть свой **агент**. Он устанавливается во все узлы K8S и **отвечает за сетевую настройку** Pod'ов. Этот агент идет либо в комплекте с конфигом CNI, либо самостоятельно создает его на узле. Конфиг помогает CRI plugin установить, какой CNI plugin вызывать.

**Что происходит при создании Pod'a?**  
**kubelet** вызывает **CRI plugin**, чтобы создать Pod, а тот уже вызывает **CNI plugin** для настройки сети Pod'а. При этом CNI plugin сетевого провайдера (например, Calico) вызывает другие базовые CNI plugins для настройки различных аспектов сети.

> kubelet -> CRI plugin -> CNI plugin -> configure the Pod network

Таким образом, CNI отвечает за организацию сетевого взаимодействия в K8S.

---
### 8. Что такое etcd и зачем он нужен? Как обновить Kubernetes?
**etcd (key-value store)** - база данных, типа ключ-значение, как MongoDB, там хранятся все переменные, по сути туда записывается состояние системы, K8S кластер можно полностью восстановить, имея резервную копию etcd.

В K8S API-server по сути является CRUD-приложением, то есть выполняет функции (create read update delete), поэтому чтобы хранить данные ему нужна база-данных (etcd).

**Почему не SQL?**  
Принципы резервной БД API-сервера:
* Согласованность (это требование исключает NoSQL и некоторые SQL БД)
* Доступность ([CAP теорема](https://ru.wikipedia.org/wiki/Теорема_CAP))
* Стабильная производительность
* Уведомления об изменениях
* Другие соображения
    * Большие наборы данных
    * Сложные запросы

**etcd** - строго согласованное распределенное хранилище ключ-значение:
* **строго согласованное**
    * практически говоря: после успешной записи от одного клиента другой клиент никогда не увидит устаревшие данные перед записью (это не относится в конечном итоге к согласованным базам данных NoSQL)
* **распределенное**
    * в отличие от традиционных баз данных SQL, etcd разработан с нуля для запуска с несколькими узлами
    * высокую доступность (хотя и не 100%) без ущерба для согласованности.
 * **ключ-значение**
    * в отличие от баз данных SQL, модель данных etcd проста и включает ключи и значения вместо произвольных связей данных
    * это помогает ему обеспечить относительно предсказуемую производительность, по крайней мере, по сравнению с традиционными базами данных SQL.

> killer feature: etcd позволяет клиентам подписываться на изменения определенного ключа или набора ключей.

Полезная [статья](https://learnk8s.io/etcd-kubernetes) по теме.

**Как обновить Kubernetes кластер?**  
[Инструкция](https://kubernetes.io/docs/tasks/administer-cluster/cluster-upgrade/) из официальной документации.

Способы обновления кластера будут зависеть от того, как его изначально развернули.

Обновление производится с помощью инструмента **kubeadm**.

Глобально нужно будет:
* Обновить мастер-Node
    * Call "kubeadm upgrade" - `kubeadm upgrade plan` и `kubeadm upgrade apply v1.26.x`
    * Drain (слить) the node - `kubectl drain <node-to-drain> --ignore-daemonsets`
    * Upgrade kubelet and kubectl
        * Restart the kubelet
    * Uncordon (откорректировать) the node - `kubectl uncordon <node-to-uncordon>`
* Обновить клиент (например, kubectl)
* Обновить рабочие Node'ы в кластере
    * Upgrade kubeadm
    * Call "kubeadm upgrade" - `kubeadm upgrade node`
    * Drain the node
    * Upgrade kubelet and kubectl
        * Restart the kubelet
    * Uncordon the node
* Скорректировать манифесты и другие ресурсы на основе изменений API
    * kubectl convert

---
## Блокчейн технологии

<div id="question_9"></div>

### 9. Стек блокчейн-технологий. Уровневая модель стека

Тема хорошо раскрыта в англоязычной [статье](https://cehv.com/cehvs-blockchain-osi-model-thesis/).

Введение:
* Широкое распространение блокчейн технологии возможно благодаря приложениям, которые будут абстрагировать пользователя от всех технологий и использовать тот протокол, который удобнее (также как это произошло с Интернетом - сейчас пользователь взаимодействует лишь с 7 уровнем Приложения сетевой модели OSI и не знает, что происходит на других уровнях стека, например ему все равно используется IPv4 или IPv6)
* Можно составить аналог OSI для бизнеса - где денежная оценка потенциала компании напрямую зависит от масштаба задач, которые она решает (есть крупные компании, которые управляют малым бизнесом, а есть мелкие компании, которые решает нишевую проблему для подмножества пользователей)
* Три сектора ценности потенциала:
  * Стимулирующие сектора
    * Они в основном состоят из физического уровня, уровня канала передачи данных и сетевого уровня
    * Пример компании: Verizon Communications
  * Сектора стандартов
    * Ценность определяется созданием единого стандарта внедрения и вспомогательных услуг на его основе
    * Пример компании: Adobe’s PDF
  * Секторы взаимодействия
    * Самые ценные - это технологические бренды и стартапы, с которыми пользователи часто взаимодействуют, причем взаимодействуют через приложения (то есть не задумываются, что за протоколы используются)
    * Примеры компаний: Microsoft, Amazon, Facebook
* Если создать гибридную модель OSI Блокчейна, можно понять куда нужно инвестировать

Модель OSI Блокчейна:
* 11-уровневая модель OSI Blockchain направлена на разделение **протоколов блокчейна** и **децентрализованных приложений** ("dApps") по уровням, которые представляют собой разделение как по **технологии**, так и по **назначению**
* Каждый из 11 уровней примерно (хотя и с выбросами) варьируется от:
  * самого низкого до самого высокого **уровней абстракции** для конечных пользователей (запущенные узлы по сравнению с использованием MetaMask) и 
  * самого низкого до самого высокого **уровней извлечения максимальной потенциальной ценности** (аппаратное обеспечение с низкой маржой, абстракция с высокой маржинальной платой за протоколы взаимодействия)
* Уровни (по возрастанию):
  1. **Физический** - инфраструктура
  2. **Канальный** - ПО физического уровня
  3. **Сетевой** - соединяет два любых физических узла
  * Микросетевой - состоит из используемого нами протокола блокчейна (например, Ethereum) и передачи данных между узлами по классическим интернет-протоколам сетевого уровня (TCP/IP)
  * Макросетевой - это инструменты и протоколы, которые соединяют узлы вместе
  4. **Информационный** - набор стандартов, процедур и протоколов того, как мы индексируем, храним и сортируем информацию
  5. **Обрабатывающий** - один из самых широких и разнообразных с точки зрения его конкретных конечных целей
  6. **Представления** - один из наиболее важных уровней для роста и развития открытой системы, и все же он часто является наиболее недофинансируемым, наименее прибыльным и наиболее забытым в любой модели систем
  7. **Программный** - создает инструменты, которые мы используем для разработки, развертывания и управления программами прикладного уровня или уровня взаимодействия, часто используя для этого существующие стандарты уровня представления
  8. **Приложения** - это то место, где большинство пользователей взаимодействуют с реальными программами, использующими коллекции базовых протоколов.
  9. **Взаимодействия** - это специальные программные наборы инструментов, которые позволяют пользователям легко взаимодействовать с приложениями, а иногда и с протоколами более низкого уровня стека (**Metamask**)
  10. **Платформы** - еще не был зафиксирован в пространстве блокчейна
  11. **Расчетный / регулирования (Settlement ?)** - абстрактный слой
  * это магистраль, соединяющая несколько слоев вместе
  * это универсальная истина, окончательность и безопасность (это то, чего не существует в классическом Интернете)

Итоги:
* На сегодняшний день проблема блокчейн сферы в том, что разработчики не могут предоставить пользователю понятный результат работы их приложения, а инвестировать в непонятную технологию, скрытую под капотом приложения не хочется.
* Понимая многоуровневые компоненты модели OSI Блокчейна и то, как они работают вместе, мы можем определить области для инвестиционных возможностей, области уязвимости / монополии, отраслевые пробелы и недостающие элементы, которые нужны, чтобы задать тренд на блокчейн-технологию.

---
### 10. Основные недостатки блокчейн-сетей на примерах различных платформ
Тема хорошо раскрыта в англоязычной [статье](https://www.researchgate.net/publication/330028734_The_Advantages_and_Disadvantages_of_the_Blockchain_Technology) (также там есть формулы для расчета параметров блокчейна).

В теории технология блокчейна может помочь решить проблему прозрачности, надежности, достоверности и безопасности обработки данных, однако на практике реализовать это **дорого** и **сложно**. Успех внедрения напрямую зависит от государственной и законодательной поддержки.

Преимущества блокчейна:
* **Децентрализованная система** решает проблему **двойных трат** без участия посредников
  * Каждый новый блок содержит:
    1. хеш предыдущего блока
    2. временную метку
    3. хеш транзакции (точнее единый хеш - корень дерева Меркла (merkle root))
      * Транзакции включают сообщения с информацией для External owned accounts (учетных записей, принадлежащих внешним пользователям, EOAs)
    4. nonce
  * Протокол Proof-of-Work (майнер передает подобранный хеш в сеть, а остальные узлы проверяют, правильно ли решена задача)
  * Протокол Proof-of-Stake
  * Смарт-контракты - это скрипты, которые хранятся в блокчейне
* **Все действия записываются**
  * Прозрачность, достоверность, неизменность данных
* **Уменьшается время обработки и инициализации транзакции** по сравнению с банковскими организациями
  * несколько минут (или даже секунд) против 3 дня (?)

Недостатки блокчейна:
* **Высокая энергозависимость**
  * Высокое энергопотребление необходимо для доступа к реестру в реальном времени
  * Майнеры тратят огромные вычислительные мощности для поддержания работы блокчейна
  * Каждый узел блокчейна обеспечивает экстремальный уровень отказоустойчивости, гарантирует нулевое время простоя и делает данные, хранящиеся в блокчейне, навсегда неизменяемыми и устойчивыми к цензуре
    * Это нужно для достижения консенсуса (алгоритм консенсуса - одно из свойств сети, которое обеспечивает согласованность реестра всеми участниками сети)
    * Данные действия сжигают электричество и время
  * Проверка подписи также требует огромных вычислительных мощностей, так как транзакции подписаны криптографиечской схемой
* **Возможность разделения цепочки (fork)**
  * **fork** - это, по сути, результат процесса деления уже существующего блокчейна на несколько ответвлений (например у Биткоина 19 форков)
    * soft fork
    * hard fork
  * Подробнее в вопросе #12
* **Баланс между количеством узлов и выгодными затратами для пользователей**
  * Сейчас для правильной и мощной работы блокчейна не хватает узлов
    * Это значит, что пользователи платят больше, потому что узлы получают более высокие вознаграждения за работу, хотя транзакции завершаются медленнее, так как узлы работают не интенсивно
  * Со временем количество блоков в блокчейне увеличивается, следовательно повышаются требования к вычислениям, однако не все узлы могут предоставить необходимую пропускную способность, что вызывает следующие проблемы:
    * Первая: уменьшение регистра, так как узлы не могут хранить полную копию блокчейна, что означает нарушение неизменяемости и прозрачности блокчейна
    * Вторая: блокчейн становится более централизованной системой
* **Высокая стоимость реализации**
  * Средняя стоимость транзакции составляет от 75 до 160 долларов
  * Это вызвано высокой энергозависимостью (которая описывалась выше) и высокими первоначальными капитальными затраты на блокчейн
* **Сложный процесс интеграции**

---
### 11. Распространенные типы уязвимостей и атак на блокчейн-сети
Перечень есть в англоязычной [статье](https://www.researchgate.net/publication/330028734_The_Advantages_and_Disadvantages_of_the_Blockchain_Technology) из предыдущего вопроса, подробное описание по ссылками ниже.

Блокчейн может быть атакован различными угрозами, которые связаны с протоколами PoW и PoS, однако большинство из них почти невозможны:
* **Атака 51%**
  * Это когда злоумышленник захватывает 51% хэш-мощности сети. Когда такой контроль есть, можно отменить любую транзакцию и делать главной выгодную цепочку (по сути произвести двойную трату)
  * Из-за того, что алгоритм консенсуса предполагает согласие большинства участников процесса на внесение изменений в реестр блокчейна, то, теоретически, некоторое количество узлов может вступить в **сговор** и проголосовать за свою версию истории транзакций
  * Учитывая общее количество узлов системы, на практике этот сценарий реализовать практически невозможно
* **Двойная трата**
  * Это повторная (иногда множественная) продажа одних и тех же средств
  * Один покупатель переводит тот же самый баланс двум получателям транзакции. Те же деньги тратятся дважды
  * Для осуществления двойной траты нужна **отсрочка во времени** между отправкой и подтверждением/получением перевода
  * Блокчейн биткоина и других криптовалют решают проблему двойных трат через:
    * механизмы **подтверждения транзакций**
    * открытый блокчейн (**свойство прозрачности**)
  * **Пример**: Предположим, у вас есть 1 BTC, который вы пытаетесь потратить дважды. Вы совершили 1 транзакцию BTC торговцу №1. Теперь вы снова подписываете и отправляете тот же 1 BTC на другой биткоин-адрес, чтобы попытаться обмануть торговца №2. Обе транзакции идут в неподтвержденный пул транзакций. Но только первая транзакция получила подтверждение и была проверена майнерами, заключена в блок. Вторая транзакция не может получить достаточного количества подтверждений, потому что майнеры считают ее недействительной.
  * Если обе транзакции приняты майнерами одновременно, то в мемпул будет добавлена та, у которой больше подтверждений (это несколько блоков, содержащих другие транзакции, которые добавляются в цепь)
* **Sybil’s attack (Атака Сивиллы)**
  * Sybil Атака представляет собой угрозу безопасности в онлайн системе, где один человек пытается захватить сеть, создав несколько учетных записей, узлов или компьютеров
  * Это может быть также просто, как один человек, создающий несколько учетных записей в социальной сети. Но в мире криптовалют более подходящим примером будет, что кто-то запускает сразу несколько узлов в blockchain цепочке
  * Слово «Sybil» в своём названии происходит из тематического исследования о женщине по имени Sybil Dorsett, которая лечилась от диссоциативного расстройства личности, также называемого "множественного расстройства личности"
  * Атакующие могут избегать настоящих узлов в сети, если они создают достаточное количество поддельных или идентичных (Sybil идентификаторов). Затем они могут отказаться от приема или передачи блоков, эффективно блокируя других пользователей в сети
  * В действительно крупномасштабных Sybil атаках, где злоумышленникам удается контролировать большое количество вычислительной мощности или хешрейта, они могут совершить **атаку в 51%**. В таком случае, они смогут изменять порядок транзакций и не допускать подтверждения новых. Они смогут даже отменять транзакции, которые совершались во время их контроля, что может привести к **двойным тратам**
  * Многие блокчейны используют разные "алгоритмы конценсуса" для защиты от Sybil атак:
    * доказательство работы (Proof-of-Work)
    * доказательство доли (Proof-of-Stake)
    * делегированное доказательство доли (Delegated-Proof-of-Stake)
  * Эти алгоритмы консенсуса, фактически не предотвращают Sybil атаку, они просто делают ее нецелесообразной, в случае если атакующий успешно её выполнил
  * Например, blockchain Биткоина применяет определенный набор правил, для генерации новых блоков. Одно из правил заключается в том, что **способность создавать блок, должна быть пропорциональна общей вычислительной мощности механизма Proof of Work**. Это означает, что вам фактически необходимо владеть своей компьютерной мощностью, требуемой для создания нового блока, что делает процесс взлома очень сложным и дорогостоящим для злоумышленника
* **DDoS-атака**
  * Еще один тип хакерских атак, идея которого заключается в пересылке большого количества похожих запросов. Биткойн имеет встроенную защиту от атак типа "отказ в обслуживании"
  * Например, размер блока ограничен до 1 МБ, чтобы усложнить забивание пулов памяти полных узлов, а размер каждого скрипта не превышает 10 тыс. байт. Также ограничено число проверок подписи, которое может затребовать блок (20 тыс.), и количество мультиподписей (20 ключей максимум)
  * При этом клиенты биткойна блокируют все подозрительные узлы и транзакции. Например, в последней версии клиента Bitcoin Satoshi добавили функцию для регистрации нестандартных транзакций (больше 100 килобайт). Также при обработке транзакций клиент проверяет, что все выходы являются "не потраченными"
* **Взлом криптографической системы**
  * Возможно, если использовать **квантовые алгоритмы**, такие как **алгоритм Шора (Shora)**, которые могут взломать шифрование RSA.
  * Алгоритм Шора - квантовый алгоритм факторизации (разложения числа на простые множители)
  * Значимость алгоритма Шора заключается в том, что с его помощью (при использовании квантового компьютера с несколькими тысячами логических кубитов (квантовых битов)) становится возможным взлом криптографических систем с открытым ключом
  * К примеру, RSA использует открытый ключ M, являющийся произведением двух больших простых чисел. Один из способов взломать шифр RSA - найти множители M. При достаточно большом M это практически невозможно сделать, используя известные классические алгоритмы
  * Алгоритм Шора, используя возможности квантовых компьютеров, способен произвести факторизацию числа за очень короткий промежуток времени. С математической точки зрения, это потребует логарифмического (`log(N)`),а не экспоненциального (`exp(N)`)количества времени (то есть практически так же быстро, как происходит само шифрование)
* **Race attack (атака-гонка)**
  * Это когда злоумышленник посылает одну и ту же монету очень быстро на два разных адреса. А продавец принимает факт оплаты без подтверждений от сети
* **Brute force attack**
  * Это когда транзакция майнится злоумышленником на форке сети

Полезные ссылки:
* [Чем опасна и как происходит двойная трата (double spending) в блокчейне Bitcoin?](https://crypto-fox.ru/faq/double-spending/)
* [Шор как угроза современной криптографии](https://habr.com/ru/post/592413/)
* [Что угрожает блокчейн-сетям: рассматриваем атаки и способы защиты](https://habr.com/ru/company/bitfury/blog/346656/)
* [Sybil Атаки](https://academy.binance.com/ru/articles/sybil-attacks-explained)

---
### 12. Понятие хардфорка, его причины и последствия. Примеры хардфорков в различных сетях
Русскоязычная [статья](https://vc.ru/finance/347805-forki-bitkoina-chto-eto-i-chem-horoshi) по теме.

**fork** - это, по сути, результат процесса деления уже существующего блокчейна на несколько ответвлений (например у Биткоина 19 форков). То есть, на основе оригинального блокчейна Биткоина создаётся новая монета с улучшенными характеристиками самого Биткоина.

Существует два вида fork'а:
* **soft fork** - это обратно совместимое изменение протокола блокчейна, которое позволяет вводить новые правила, не требуя от всех пользователей обновления своего программного обеспечения
  * При soft fork'е большинство майнеров сети внедряют новые правила и начинают следовать обновленной версии блокчейна. Остальная часть сети может продолжать следовать старой версии блокчейна, но они не смогут проверять новые блоки, которые следуют обновленным правилам
  * Поскольку программный soft fork обратно совместим, он не приводит к созданию нового блокчейна или разделению сети
* **hard fork** - это изменение протокола блокчейна, которое не является обратно совместимым и требует от всех пользователей обновления своего программного обеспечения, чтобы продолжать участвовать в сети.
  * При hard fork'е сеть разделяется на две отдельные версии: ту, которая следует новым правилам, и ту, которая следует старым правилам
  * Если новый fork увеличивает размер блока с 1 МБ до 2 МБ и старый блок прошел через все правила hard fork'а, то блок будет принят, даже если блок ранее **не был в цепочке (?)**

Зачем нужны fork'и?
* Форки позволяют внести определенные изменения в работу сети
  * Например, fork монеты может работать на другом алгоритме (переход с PoW на PoS)
* Позволяют исправить баги или недоработки сети
  * Например, монета с большей памятью, большей скоростью майнинга, лучшей децентрализацией или масштабируемостью
* С помощью форков можно создать новый продукт на основе уже проверенной технологии блокчейн

Разница между soft fork и hard fork:
* hard fork подразумевает использование **либо** оригинальной монеты, **либо** её fork'а (**сеть разделяется**). Пользователь должен определиться, какую монету он собирается использовать
* soft fork'и же позволяют **совмещать** оригинальную и fork монету (**сеть не разделяется**)

Популярные fork'и Биткоина:
* Bitcoin Cash (BCH)
* Bitcoin Gold (BTG)
* Bitcoin Diamond (BCD)
* Lightning Bitcoin (LBTC)

---
### 13. Экосистема Polkadot и ее архитектура. Типы и роли узлов в экосистеме
Важно понимать, что технология блокчейна не ограничивается одним блокчейном, также как нельзя говорить про Интернет только про протокол TCP. Пользователю важнее инфраструктура вокруг блокчейна, чем сам блокчейн.

**Polkadot** - экосистема, протокол, который позволяет создавать сеть взаимодействующих блокчейнов. В основе Polkadot'а лежит фреймфорк для создания кастомизированных блокчейнов **Substrate**. Polkadot создан в 2020 году. В статье Polkadot называют сгементированным (sharded) блокчейном, так как цепочки внутри него могут обрабатывать транзакции параллельно. 

Свойства экосистемы Polkadot:
* Масштабируемость
* Легкость в обновлении/управлении
* Shared security (Совместная безопасность)
  * То есть каждый берет на себя ответственность за определенную часть защиты (?), подробнее в вопросе #14
* Совместимость

Polkadot состоит из [4 основных компонентов](https://medium.com/@megavan0535/polkadot-процесс-получения-слота-парачейн-6973ee9ebc7a):
1. **Основная сеть (Relay Chain)** - это своеобразная «сердцевина», которая обеспечивает общую безопасность, консенсус и **межплатформенное взаимодействие** (взаимодействие между участниками). Благодаря этой технологии другие проекты в экосистеме Polkadot могут максимально сосредоточиться на разработке своих продуктов.
2. **Парачейны (Parachains)** - это **полноценные и независимые блокчейны**, которые могут иметь собственные токены и инструменты для решения конкретных задач. Работают в сети Relay Chain. Их будут создавать сторонние разработчики и присоединять к общей сети Polkadot.
  * Парачейны требуют ресурсов, чтобы гарантировать, что они останутся безопасными. Слоты для парачейна - дефицитный ресурс на Polkadot. По мере роста количества парачейнов каждые несколько месяцев может открываться всего несколько слотов, которые продаются на свечном аукционе.
    * Свечные аукционы - это разновидность открытых аукционов, на которых участники торгов делают все более высокие ставки, а победителем считается тот, кто предложит самую высокую цену по завершении аукциона.
    * Алгоритм выбора победителя будет выбирать ставки, которые могут не перекрываться, чтобы максимизировать количество токенов, удерживаемых в течение всего срока аренды слота парачейна.
  * Валидаторы проверяют функцию смены состояния парачейна.
3. **Паратреды (Parathreads)** - это параллельные цепочки блоков, которые по своей технологии схожи с парачейнами. Но отличаются тем, что **могут быть арендованы** мгновенно и на любой промежуток времени.
4. **Межсетевые мосты (Bridges)** тоже имеют схожесть с парачейнами. Но их основная (и фактически единственная) задача заключается в том, чтобы обеспечить **связь экосистемы Polkadot со сторонними блокчейнами**. Например, Bitcoin, Ethereum, Binance Chain и прочими.

В качестве внутренней валюты проекта используется **токен DOT**, а стабильность экосистемы обеспечивают **валидаторы**, задача которых заключается в том, чтобы добавлять и проверять блоки в разных парачейнах. Сами валидаторы тоже находятся под контролем надежных алгоритмов, благодаря которым гарантируется безопасность всей сети.

В Polkadot'е используется модернизированный алгоритм консенсуса Proof-of-Stake - **Nominated PoS**.

Стадии консенсуса:
> Сопоставление -> Резервное копирование блоков -> Проверка доступности блоков -> Утверждения/Споры (GRANDPA consensus) 

Типы узлов в Polkadot:
* **Validators (Валидаторы)** - узлы, которые отвечают за создание и проверку новых блоков.
  * Polkadot ограничивает **количество активных валидаторов** в сети. По мере увеличения количества подключенных парацепей активный набор достигнет максимального размера в 1000 валидаторов. Это ограничение является результатом компромисса между безопасностью и производительностью. Чем больше количество валидаторов в системе, тем выше ее безопасность; однако пропускная способность системы снижается, поскольку требуется больше времени для достижения консенсуса между всеми узлами.
  * Валидаторы образуют и защищают сеть, обеспечивая работу предоставляемых ею сервисов путем создания новых блоков и проверки блоков parachain. Они действуют бессрочно, при этом используются собственные токены сети, которые поддерживают их как валидаторов и стимулируют их постоянное соблюдение правил протокола. За нарушение правил они несут наказание (обычно называемое "слэш"), в то время как за соблюдение правил они получают долю от сборов, получаемых от использования услуг сети.
  * В NPoS валидаторы должны быть избраны для участия в каждом активном наборе, что составляет определенный период времени, как правило, становящийся более продолжительным при последней высоте блока. Именно здесь на помощь приходят **номинаторы**.
  * Валидаторам присваиваются активные слоты пропорционально их номинациям. Таким образом, валидаторы, которые получили больше номинаций и большее количество жетонов за них, имеют больше шансов быть избранными в следующий активный набор валидаторов.
* **Nominators (Номинаторы)** - это держатели токенов (DOT), которые вносят свой вклад в безопасность сети, экономически поддерживая (назначая) до 16 валидаторов по своему выбору своими токенами ("долей").
  * Номинаторы также владеют токенами, но не принимают активного участия в консенсусе. Вместо этого они пользуются своей экономической поддержкой (в виде принадлежащих им токенов), чтобы номинировать избранных ими валидаторов на активные слоты. Стимулом для номинантов является вознаграждение, которое получают валидаторы, назначенные ими в активные слоты. Как и валидаторы, они также должны соблюдать правила протокола, иначе им грозят штрафы.
  * Так как награды в конечном итоге распределяются пропорционально общей доле валидатора, номинанты получают большее вознаграждение за выдвижение, возможно, менее известных валидаторов, которые могут иметь меньшие доли, поддерживающие их. Это стимулирует номинаторов к поиску более разнообразной группы валидаторов, вместо того чтобы выдвигать одних и тех же в каждом наборе.
* **Collators (Cборщик)** - это узел, ответственный за поддержание своей цепочки закупок.
  * Сборщики поддерживают работу Парачейнов и Межсетевых мостов.
  * Проводят процедуру доказательства нового перехода (Proofs of new state transitions), которую затем подтверждает валидатор.
  * Таким образом, задачи сборщиков заключаются в том, чтобы:
    * поддерживать свою соответствующий Парачейн и хранить его данные
    * обмениваться сообщениями с другими Парачейнами, используя формат XML
    * создавать кандидатов на блок Парачейна
    * генерировать доказательство перехода состояния Парачейна (PoV), которое является доказательством / кратким изложением переходов состояний Парачейна
    * в случае сборщика Parathread'а, предложить ставку в DOT на аукционе по блокам

Полезные ссылки:
* [Analysis of Polkadot: Architecture, Internals, and Contradictions](https://arxiv.org/pdf/2207.14128.pdf)
* [Polkador: vision for a heterogeneous multi-chain framework](https://polkadot.network/PolkaDotPaper.pdf)
* [Что такое Номинаторы простыми словами](https://tgdratings.com/ru/glossary/nominators/)

---
### 14. Принцип shared security и его применение в блокчейн-сетях
**Shared/pooled security (Общая/объединенная безопасность):**  
Безопасность в Polkadot является общей - все подключенные Парачейны (Parachains) автоматически получают **одинаковый уровень безопасности**, обеспечиваемый Основной сетью (Relay Chain).

Это делается для того, чтобы обеспечить работоспособность всей системы и чтобы ни один отдельный компонент не был подвержен **коррупции**.

Безопасность не зависит от количества цепочек, а **зависит только от валидаторов**, которые имеют достаточно большое количество DOT (токен Polkadot'a), поддерживающих их. Номинаторы и валидаторы вносят свой вклад в безопасность сети, блокируя свои средства (речь идет о **стейкинге**, смотри билет #15).

Номинаторы разделяют с валидаторами как вознаграждении, так и наказании валидаторов, за которых они голосовали. **Избирательный процесс Фрэгмена** определяет победителей, находя комбинацию, которая приводит к
тому, что доля (стейк, stake) имеет наибольшую ценность. В PoS-системах самыми важными показателями
безопасности сети являются размер стейка и цена риска.

> Это означает, что чем больше количество DOT, поставленных честными валидаторами и номинаторами, тем больший объем данных требуется злоумышленнику для получения слотов валидатора.

**Следствие общей безопасности:**    
Чтобы обратить (удалить) блок Парачейна, злоумышленнику придется **обратить всю систему** Polkadot, включая все другие Парачейны. Это связано с тем, что блоки Relay Chain хранят доказательства достоверности из Парачейнов, что означает, что когда цепочка завершается, этот блок Парачейнов также завершается. Эта общая безопасность обеспечивает необходимые гарантии для обеспечения надежной межцепочечной (cross-chain) связи между ненадежными объектами (сущностями).

Понятие общей безопасности отличается от межцепочечных (inter-chain) протоколов, которые основаны на архитектуре мостов. Для **мостовых протоколов** каждая цепочка считается независимой и должна поддерживать свой собственный набор валидаторов и экономическую безопасность. Одна из проблем этих протоколов связана с **масштабируемостью безопасности**.

Например, одним из предложений по масштабированию блокчейнов является масштабирование по альткоинам, которое предполагает, что объемы транзакций будут снижаться до альткоинов с более низкой рыночной капитализацией по мере того, как более крупные будут заполнять свои блоки. Главный недостаток этой идеи заключается в том, что монеты с более низкой рыночной капитализацией будут иметь меньшую экономическую безопасность и их будет легче атаковать.

Polkadot решает проблемы масштабируемости безопасности, поскольку он привлекает все экономические стимулы к Relay Chain и позволяет Парачейнам использовать более надежные гарантии в **genesis (? возможное пояснение ниже)**. Суверенные сети должны прилагать гораздо больше усилий для увеличения стоимости своей монеты, чтобы она была достаточно защищена от хорошо финансируемых злоумышленников.

Polkadot включает в себя блокчейн, называемый Relay Chain. Блокчейн - это **ориентированный ациклический граф** (DAG) переходов состояний, где каждый добавленный блок можно рассматривать как начало цепочки или форк с кумулятивным состоянием. Все пути через DAG заканчиваются в **блоке Genesis**. Блокчейн - это дерево, поскольку каждый блок может иметь только одного родителя.

Полезные ссылки:
* [Analysis of Polkadot: Architecture, Internals, and Contradictions](https://arxiv.org/pdf/2207.14128.pdf)
* [Parachains](https://wiki.polkadot.network/docs/learn-parachains)

---
### 15. Механизм стейкинга токенов в различных сетях
Тема хорошо разобрана в [здесь](https://academy.binance.com/ru/articles/what-is-staking).

**Стейкинг** можно рассматривать как менее ресурсоемкую альтернативу майнингу. Он заключается в **хранении средств** на криптовалютном кошельке для поддержки безопасности и активности сети. Проще говоря, стейкинг - это блокировка криптовалюты для получения вознаграждения.

**Как работает стейкинг?**  
Блокчейны с Proof of Work используют майнинг для добавления новых блоков в блокчейн, а сети с Proof of Stake производят и проверяют новые блоки с помощью стейкинга. **В стейкинге участвуют валидаторы, которые блокируют свои монеты, чтобы получить возможность быть выбранными для создания блока.** Обычно участники, которые добавляют в стейкинг большие суммы, имеют больше шансов быть выбранными в качестве валидатора следующего блока.

Стейкинг позволяет **создавать блоки без использования специализированного оборудования** для майнинга, такого как интегральные схемы специального назначения (ASIC). В то время как майнинг требует значительных инвестиций в оборудование, стейкинг **подразумевает прямые инвестиции в саму криптовалюту**. Таким образом, вместо того, чтобы конкурировать за следующий блок с помощью вычислительной мощности, валидаторы PoS выбираются на основе количества заблокированных монет. Монеты, размещенные в стейкинге, или доля - это то, что стимулирует валидаторов поддерживать безопасность сети. Если они не будут соблюдать данное условие, их средства могут оказаться под угрозой.

В большинстве цепочек работающих на Proof of Stake присутствует **своя валюта для стейкинга**, а некоторые сети используют систему с двумя токенами для разделения выплат в качестве вознаграждения.

На практике стейкинг - это просто хранение средств на специальном кошельке, которое позволяет любому пользователю выполнять различные сетевые функции в обмен на вознаграждение. Механизм также предлагает возможность добавления средств в **стейкинг-пул**, о котором мы расскажем чуть позже.

**Стейкинг-пул** - это группа владельцев монет, которые объединяют ресурсы, чтобы с большей вероятностью получить право на валидацию блоков и вознаграждение.

**Как рассчитывается награда за стейкинг?**  
На этот вопрос вы не получите четкий и короткий ответ, по той простой причине, что каждая блокчейн-сеть может использовать свой способ расчета вознаграждений за стейкинг:
* Некоторые из блокчейнов корректируют награду от блока к блоку, принимая во внимание множество различных факторов. Это может включать в себя:
  * Количество монет валидатора 
  * Продолжительность нахождения доли валидатора в стейкинге
  * Общее количество монет выделенных на стейкинг 
  * Уровень инфляции
  * Другие факторы
* В некоторых сетях вознаграждение за стейкинг определяется в виде фиксированного процента. Эти вознаграждения распределяются между валидаторами как компенсация за инфляцию. Инфляция побуждает пользователей тратить монеты вместо того, чтобы размещать их в стейкинге, что может увеличить спрос на них в качестве криптовалюты. На основе такой финансовой модели валидаторы могут точно рассчитать, какое вознаграждение за стейкинг им следует ожидать.

**Холодный стейкинг** - это процесс стейкинга с использованием кошелька, не подключенного к интернету.

---
### 16. Виды on-chain управления блокчейн-сетями
**Управление блокчейн-сетью** в первую очередь касается процесса принятия решения об **обновлении протокола**.

Управление блокчейном обычно делится на **две категории**:
* **on-chain** управление
  * Это механизм, который позволяет децентрализованному сообществу обновлять блокчейн, **голосуя непосредственно в сети**
    * Процессы принятия решений проходят через стейкинг и транзакции **на блокчейне**
  * Характерно для бокчейнов, использующих алгоритм PoS (Ethereum)
* **off-chain** управление
  * Процессы принятия решений проходят через **неформальные** процессы обсуждения и предложения **вне блокчейна**
    * Для off-chain модели характерно обсуждение вопросов разработки протоколов на конференциях, онлайн-форумах и посредством почтовых рассылок. Чтобы принять участие в управлении, вам необходимо использовать эти каналы
  * Характерно для бокчейнов, использующих алгоритм PoW
  * Недостатки:
    * Трудно зарегистрировать свой вклад как отдельного пользователя
    * Реализация изменений (обновлений) может занять много времени

**Механизмы on-chain управления:**  
* on-chain управление характерно для блокчейнов с доказательством доли участия и проводится в форме **голосования**. Вы, как правило, должны владеть собственным токеном блокчейна, чтобы участвовать в управлении.
* **Вес вашего голоса** определяется количеством токенов, которыми владеете. Заинтересованные стороны в on-chain управлении - это пользователи, разработчики и валидаторы транзакций.
* Например, если у вас есть токен MKR MakerDAO, вы можете участвовать в управлении и голосовать по предложениям, внесенным сообществом Maker через его **децентрализованную автономную организацию (DAO)**.
  * Это может быть, например, добавление нового типа залога в долговую систему MakerDAO. **Каждое предложение записывается в смарт-контракт**, и когда оно получает необходимое количество голосов, изменения в блокчейне выполняются немедленно.

**Преимущества on-chain управления:**  
* Расширяет группу людей, участвующих в процессах управления блокчейном
* Ограничивает угрозу форков
* Позволяет отдельным пользователям регистрировать свой вклад

**Недостатки on-chain управления:**  
* История про **ошибку в смарт-контракте DAO** децентрализованного инвестиционный фонда, которая привела к hard fork'у Ethereum и появления **Ethereum Classic**
  * Проблема была в том, что ошибку нельзя была исправить - как только код смарт-контракта начал выполняться, его нельзя остановить, редактировать, потому что он запускается на всех узлах сети
  * Предложения представленные в DAO проверяются **кураторами**, однако до сих пор остается вопрос над областью их полномочий
* Реализация большинства существующих механизмов on-chain управления напоминает скорее **плутократию** (т.е. "правление богатых"), чем демократию
  * fork иллюстрирует одну из ключевых особенностей управления блокчейн-системами: конечная управляющая власть принадлежит **отдельным майнерам** или **держателям токенов**
* on-chain управление не застраховано от **внешних воздействий**
  * Организации, не участвующие непосредственно в сети, могут попытаться сформировать мнение майнеров или крупных держателей токенов с помощью **социальных сетей** или кампаний в **СМИ**
  * Они могут создавать стимулы (например, **льготы** или **взятки**) или сдерживающие факторы (например, **санкции** или **штрафные санкции**) **вне системы**, чтобы изменить то, как участники осуществляют свои права внутри системы
* on-chain управление так и не смогло решить проблему, которую изначально планировало:
  * Пользователи могут злоупотреблять техническими или экономическими правилами Daps (децентрализированных приложений) **в своих собственных интересах**

> on-chain управление в конечном счете зависит от правил off-chain управления.

Виды on-chain управления в системе Polkadot.
Для безопасности сеть Polkadot'а объединяет различные новые механизмы, включая **аморфную функцию перехода состояния**, хранящуюся в цепочке и определенную на нейтральном для платформы промежуточном языке (т.е. WebAssembly), и несколько механизмов голосования в цепочке, таких как референдумы с адаптивными порогами сверхмалого большинства и голосование за пакетное одобрение.

**Референдумы**:  
* Референдумы - это простые, всеобщие схемы голосования, основанные на ставках. С каждым референдумом связано конкретное **предложение**, которое принимает форму вызова привилегированной функции в среде выполнения
* Референдумы являются дискретными событиями, имеют фиксированный период, в течение которого происходит голосование, а затем подсчитываются и выполняется вызов функции, если голосование одобрено
* Референдумы всегда бинарны; существуют варианты голосования - "за", "против" или полное воздержание
* Все референдумы связаны с задержкой вступления в силу

В Polkadot есть два способа **предложить референдум**:
* **Публичный референдум**
  * Любой желающий может предложить референдум, внеся минимальное количество токенов на определенный период (количество блоков). Если кто-то согласен с предложением, он может внести такое же количество токенов, чтобы поддержать его - это действие называется **одобрением**. Предложение, получившее наибольшую обязательную поддержку, будет выбрано для проведения референдума в следующем цикле голосования.
* **Референдумы в Совете**
  * **Единогласный совет** - когда все члены совета соглашаются с предложением, оно может быть вынесено на референдум. Этот референдум будет иметь отрицательное смещение явки (то есть, чем меньше количество голосов по ставкам, тем меньше сумма, необходимая для его проведения)
  * **Совет большинства** - когда достигается согласие только простого большинства членов совета, референдум также может быть проголосован, но он будет проведен большинством голосов (победит 51%).

**Совет** представляет пассивную заинтересованную сторону, является on-chain сущностью, состоящую из нескольких участников, каждый из которых представлен в виде учетной записи (аккаунта) в сети.
* Совет призван в первую очередь решать **три задачи управления**:
  * Предлагать разумные референдумы
  * Отменять бесспорно опасные или злонамеренные референдумы
  * Избирать технический комитет

Полезные ссылки:
* [Обзор механизмов управления в блокчейнах](https://vc.ru/u/642470-top-traders/221198-obzor-mehanizmov-upravleniya-v-blokcheynah)
* [Governance of blockchain systems: Governance of and by Distributed Infrastructure](https://hal.science/hal-02046787/document)
* [Governance](https://wiki.polkadot.network/docs/learn-governance#proposing-a-referendum)

---
### 17. Блокчейн. Его основные характеристики
**Блокчейн** - это распределенный реестр, который хранится на независимых друг от друга компьютерах. Данные в реестре обновляются только когда вносятся новые записи, и при условии, что они содержат одобренные большинством пользователей зашифрованные транзакции.

Кроме того, **блокчейн** можно воспринимать как **автомат состояний**. Подробнее в билете #20.

**Свойства блокчейна**:
* **Распределенность**
  * Данные хранятся на всех компьютерах сети одновременно. Каждый компьютер сам отвечает за обновление и синхронизацию.
* **Необратимость записи**
  * Записи можно добавлять, но не удалять. Никто не может изменить уже одобренные транзакции
* **Неоспаримость владения**
  * В информации о каждой транзакции содержатся данные, которые однозначно подтверждают баланс на счету каждого из участников сети.
* **Прозрачность**
  * Необратимость записи и неоспоримость владения позволяют каждому участнику просмотреть данные по обновлениям системы, начиная с самой первой транзакции.
* **Алгоритм консенсуса**
  * Общая версия реестра согласована всеми участниками сети.

Распределенный реестр, в отличие от централизованного, не имеет единого "пункта управления", и это свойство сильно усложняет варианты мошенничества с данными, которые он содержит.

Технология блокчейна лежит в основе криптовалюты Биткоин.

**Биткоин** - система платежей, где все транзакции совершаются **без участия посредников**, созданная Сатоши Накомото 1 ноября 2008 года. Биткоин возник как реакция на неадекватные действия крупных банков и был призван защитить простых людей от мошенничества. Неуязвимость Биткоина основана не на том, что реестр информации невозможно взломать, а на том, что это **бессмысленно**.

[Видео-демонстрация](andersbrownworth.com) того, как работает каждая из частей блокчейна (хэширование, подбор nonce и т.д) 

Сферы применения:
* Криптовалюта
  * Примеры проектов: Ethereum
* Государственное управление
  * Примеры проектов: Borderless, ID2020
* Электронное голосование
  * Примеры проектов: Follow My Vote, E-Residency
* Авторское право
  * Примеры проектов: Ascribe
* Маркировка бриллиантов (?)
  * Примеры проектов: Everledger
* Медицина
  * Примеры проектов: MedRec
* Логистика (Цепочки поставок)
  * Примеры проектов: Blockverify

---
### 18. Алгоритмы консенсуса. PoW, PoS, DPoS и прочие
Тема хорошо разобрана [здесь](https://media.sigen.pro/guides/1526) и [здесь](https://academy.binance.com/ru/articles/what-is-staking).

* **Алгоритм консенсуса**
  * это правила, по которым происходит генерация блоков в блокчейне.
  * это способ, благодаря которому децентрализованные ноды сети достигают согласия (или консенсуса) о текущем состоянии данных во всех блоках.
    * Верны ли балансы и подписи, все ли транзакции корректны?

**Proof of Work (доказательством выполнения работы)**  
* Это механизм, который позволяет собирать транзакции в блоки и соединять их вместе для создания блокчейна. Майнеры соревнуются в решении сложной математической головоломки за право добавить следующий блок в блокчейн.
* Рекомендую посмотреть [видео-демонстрацию](andersbrownworth.com) того, как работает каждая из частей блокчейна (там все, что описано ниже: хэширование, подбор nonce и т.д)
* **Как происходит майнинг?**   
	Основные ресурсы майнера обычно сосредоточены на подтверждении транзакций внутри сети.
	Последние транзакции внутри сети записываются в пул памяти - своего рода комнату ожидания, где транзакции ждут проверку.
	Чтобы транзакция прошла успешно, майнер проверяет их достоверность и собирает в блок-кандидат.
	Чтобы сделать блок-кандидат полноправной частью блокчейна, майнеру нужно решить криптографическую головоломку.
* **Этапы майнинга:**
  * **Хэширование**
    * Биткоин использует алгоритм хеширования SHA-256. Сколько бы данных на вход ни получил этот алгоритм, на выходе будет строка данных длиной в 64 знака.
  * **Создание корневого хеша**
    * После хеширования данных каждой отдельной транзакции, все полученные хеши разбиваются по парам, и каждая пара преобразуется в один хеш. 
  * **Подбор значения nonce**
    * Далее майнер хеширует корневой хеш блока-кандидата с хешем предыдущего блока и неким числовым значением, которое называют nonce.
    * Корневой хеш блока-кандидата и хеш предыдущего блока изменить нельзя, поэтому задача майнера — подобрать такое значение nonce, при котором хеш всех трех элементов будет соответствовать условиям, которые прописаны в самом коде блокчейна (например, для системы Биткоина нужный хеш буденачинаться с определенного количества нулей). Именно операция подбора nonce требует высоких вычислительных мощностей.
  * **Передача и проверка**
    * Далее первый решивший задачу майнер передает подобранный хеш в сеть, а остальные узлы проверяют, правильно ли решена задача. Такую системподтверждения называют Proof-of-Work — подтверждением работы. 
    * Проверить ответ на порядок проще, чем найти его.
* Вознаграждение - новые монеты.
* **Недостатки PoW-алгоритма:**
  * Майнинг слишком энергозатратен (большое количество произвольных вычислений).
  * Пользователям приходится платить майнерам комиссии за проверку транзакций. 
  * Низкая скорость и плохая масштабируемость.
  * Централизация майнеров, объединяющихся в пулы.

**Proof of Stake (доказательство доли)**  
* Его основная идея в том, что участники могут блокировать свою долю монет (в стейкинге), и через определенные промежутки времени протокол случайным образом предоставляет одному из них право на валидацию следующего блока. При этом вероятность выбора валидатора пропорциональна количеству монет: чем больше монет заблокировано в системе, тем выше шансы получить такую возможность.
* Еще раз, в PoS нет майнинга. Вместо решения математических задач новые монеты добываются за счет стейкинга - механизма, позволяющего добавлять новые блоки за счет доказательства владения криптовалютой этой сети.
* Таким образом, выбор участника, который получит право создать блок, зависит не от скорости решения задачи, как в случае с Proof of Work, а от количества монет в стейкинге.
* Чтобы стать валидатором, надо обладать минимально необходимым количеством монет.
* **Основные преимущества PoS-алгоритма:**
  * Низкое энергопотребление в сравнении с PoW-алгоритмами
  * Не нужно специальное оборудование (майнеры)
  * Высокая скорость и масштабируемость. Например, скорость сети TRON - 2 000 транзакций в секунду
  * Низкие комиссии
  * Участие в развитии проекта. Валидаторы должны принимать участие в голосованиях по вопросам будущего развития проекта
* **Недостаток PoS-алгоритма** - угроза централизации
  * Валидаторы с наибольшим количеством монет в конечном итоге будут контролировать большую часть сети.
 
**Delegated Proof-of-Stake (делегированное доказательство доли владения, DPoS)**  
* Разновидность PoS-алгоритма, созданная разработчиком Дэном Ларимером в 2014 году. DPoS задумывался как альтернатива PoW и PoS. Его цель - лишить валидаторов возможности централизации. Среди известных блокчейнов на DPoS: EOS, Steemit и Tezos.
* DPoS - это более демократическая версия Proof-of-Stake. Главное отличие двух алгоритмов в том, что в DPoS держатели монет (свидетели) передают свое право одобрять операции и получать награду, то есть делегируют свой голос заранее выбранному валидатору (делегату). Делегатом может стать любой пользователь сети. Но в любой момент свидетели могут отозвать свой голос - это способ позволяет избежать излишней централизации и захвата сети недобросовестными участниками.
* Делегаты объединяются в особый пул, который имеет право вносить изменения в ряд параметров сети: время добычи новых блоков, их размер и так далее. Но отменять транзакции или проводить ложные операции делегаты не могут. Поэтому у свидетелей остается власть над сетью.
* **Преимущества DPoS-алгоритма:**
  * Высокая скорость и большее масштабирование:
    * В сети работает значительно меньше нод, чем в PoW или PoS, что позволяет достаточно быстро создавать новые блоки. 
**Недостатки DPoS-алгоритма**
  * При низкой активности участников сети сохраняется угроза централизации.
  * Также возможно проведение DDoS-атак и недобросовестное поведения делегатов, которые могут вызвать сбои в сети.
 
**Leased Proof-of-Stake (арендованное доказательство доли владения, LPoS)**  
* Еще один вариант PoS-алгоритма, разработанный специально для блокчейна Waves.

**Proof-of-Importance (доказательство значимости, PoI)**  
* Еще одна вариация PoS-алгоритма, разработанная для блокчейна NEM в 2015 году.

**Proof-of-Authority (доказательство полномочий, PoA)**  
* Это алгоритм консенсуса, учитывающий «заслуги» и рейтинг валидаторов. Он считается эффективным механизмом для частных блокчейнов, впервые был концептуализирован в 2014 году одним из создателей Ethereum Гэвином Вудом и уже несколько лет используется в облачной платформе Microsoft Azure, которая включает более 200 продуктов и служб.
* PoA - это своеобразная попытка объединить PoW и PoS. Здесь вообще нет майнинга, а, следовательно, нет гонки вычислительного оборудования, как и огромных расходов энергии. В PoA для генерации блоков валидаторы используют не мощность оборудования или количество монет, а собственную репутацию.
* Так, за работоспособность сети отвечает фиксированное число валидаторов, которые были выбраны участниками сети или разработчиками проекта. Такой подход гарантирует высокую скорость обработки транзакций и хорошую масштабируемость. При этом валидаторы заинтересованы в том, чтобы их работа была честной и прозрачной, иначе они потеряют свой статус и репутацию надежного участника сети. 
* **Главный недостаток PoA-алгоритма** - возможность излишней централизации и отсутствие мотивации пользователей, которые не получают вознаграждения за майнинг или стейкинг. Более того, в рамках классического PoA обычный пользователь никак не может повлиять на работу блокчейн-сети, поскольку этим занимаются доверенные ноды, как правило, принадлежащие одной компании.
* Криптопроекты, использующие PoA, прекрасно понимают недостатки консенсуса и пытаются обойти их разными способами. Например, разработчики криптовалюты UMI в попытках избавиться от ограничений PoA создали свою вариацию этого алгоритма. Основные отличия механизма PoA в UMI от классического PoA - децентрализация и стейкинг. 
 
**Proof-of-Space (доказательство пространства, PoSpace; также встречается название Proof-of-Capacity, доказательство работоспособности, PoC)**  
* Алгоритм, использующий для подтверждения блока место на жестком диске, а не вычислительную мощность компьютера. 
 
**Proof-of-Burn (доказательство сжигания, PoB)**  
* Алгоритм, альтернативный классическим PoW и PoS. 

**Proof-of-Elapsed-Time (доказательство истекшего времени, PoET)**  
* Алгоритм консенсуса от компании Intel. Считается одним из самых сбалансированных и совершенных консенсусных алгоритмов и используется в основном корпоративными блокчейнами, например, Hyperledger.

---
### 19. Сложность сети, размер блока, очередь транзакций
**Сложность сети** - это параметр, который указывает, насколько быстро сеть майнит новый блок. Она показывает количество вычислений, которое должно проделать майнинг-оборудование, чтобы найти блок. Сложность сети биткоина постоянно растет.

**Размер блокчейна** - размер информации, которая хранится у каждого майнера этой криптовалюты.

**Блок** - перманентно записываемые файлы в сети Bitcoin, содержащие информацию о произошедших транзакциях. Каждый блок имеет ограничение по размеру. Размером блока называют предельное значение величины заполненного транзакциями блока. Например, размер блока в сети Биткоин сейчас **ограничен 1 Мб**.

Приближение размера блоков к граничному значению приводит к возникновению следующих проблем:
* Замедление работы сети
* Увеличение комиссий за транзакции

Среди возможных вариантов решения проблемы размера блоков можно назвать следующие:
* Увеличение размера блока
* Технология раздельного заверения (SegWit)
* Динамический размер блока

**Строение блока**
Поле | Описание | Размер
| -------|----------|-----|
Magic no | Значение всегда равно 0xD9B4BEF9	| 4 байта
Размер блока (blocksize) | Число последующих байтов, оставшихся до конца блока | 4 байта
Заголовок блока (blockheader)	| Состоит из 6-ти компонентов (смотри ниже) | 80 байтов
Счётчик транзакций (transaction counter) | Положительное целое число VI = VarInt | 1-9 байтов
Транзакции (transactions)	| Список транзакций	| Множество транзакций

Структура заголовка блока:
* Временная метка
  * Время создания блока
* Версия
  * 1.0 (криптовалюта)
  * 2.0 (смарт-контракт
  * 3.0(DAPPS)
  * 4.0 (блокчейн для промышленности)
* Корень Merkle
  * Суммарный хеш нескольких транзакций
* Целевая сложность
  * Определяет сложность и вычислительную мощность, необходимые для майнинга сети
* Nonce
  * Число, которое подбирают майнеры, решая криптографическую уравнение
* Предыдущий хеш
  * Каждый последующий блок должен хранить информацию о предыдущем

**Очередь транзакций** - последние транзакции внутри сети записываются в пул памяти, своего рода комнату ожидания, где транзакции ждут проверку. В цепочке транзакций в первую очередь идет подтверждение тех из них, которые имеют самую высокую комиссию. Именно они имеют большой шанс "пройти" без задержек, т.к. они наиболее приоритетны для сети биткоина. Если экономить, то операция может исполняться даже более трех суток. В тех случаях, когда транзакция из-за низко установленной комиссии не может попасть в блок, все монеты возвращаются отправителю. Обычно это происходит по истечении трех суток.

**Свойство атомарности транзакции**: если ваша транзакция попала в Main pull, то ее необратить, только если перебить с помощью посылки второй транзакции с таким же nonce.

Полезные ссылки:
* [Что такое загруженность сети биткоин и как с ней справляться?](https://ispace.news/teach-crypto/cto-takoe-zagruzennost-seti-bitkoin/)
* [Блок](https://ru.bitcoinwiki.org/wiki/Блок)
* [Блокчейн: Размер блоков](https://utmagazine.ru/posts/21846-blokcheyn-razmer-blokov)
* [Блокчейн и заголовок блока](https://translated.turbopages.org/proxy_u/en-ru.ru.d2c009c8-63bdf1d6-d156ac70-74722d776562/https/www.geeksforgeeks.org/blockchain-and-block-header/)

---
### 20. Проблема двойной траты, параметры транзакции, пропускная способность сети
**Двойная трата** - это повторная (иногда множественная) продажа одних и тех же средств. Подробно описана в вопросе #11.

Основные параметры транзакции:
* Цифровой адрес отправителя
    * From: 0x48C89c341C5960Ca2Bf3732D6D8a0F4f89Cc4368 
* Цифровой адрес получателя
    * To: 0x367adb7894334678b90аfe7882a5b06f7fbc783a
* Сумма транзакции
  * Value: 0.0001
* Хеш транзакции
  * Уникальный идентификатор транзакции, созданный с помощью алгоритма шифрования
  * Transaction Hash: 0x617ede331e8a99f46a363b32b239542bb4006e4fa9a2727a6636ffe3eb095cef

**Транзакции** - количество транзакций, которые "поселяются" в одном блоке.
**Сборы (Fees)** - общий размер дополнительной платы, который был собран с участников сети за проведение транзакций.
**Рекомендуемая комиссия за транзакцию** - это предпочтительный размер комиссии. Пользователь может увеличить это число по собственному желанию, если захочет ускорить попадание транзакции в блок.
**Время между блоками** - среднее время, за которое находится блок. Если это значение становится слишком высоким (дольше 10 минут между блоками), то чтобы это выправить, сложность сети понижается.

**Среднее количество транзакций в секунду (Transactions-per-second)**
* **TPS метрика** не всегда отражает **реальное качество** предоставляемого пользователям сервиса
* Измерения TPS пришли к нам из **распределенных баз данных**
  * TPS в базах данных - это некоторые **стандартизованные** для теста транзакции или их наборы (сколько то INSERT, сколько-то UPDATE, столько DELETE-ов на фоне постоянных SELECT) для **жестко заданной конфигурации** кластера или вообще на одной машине
* Чтобы говорить о заветных "transactions per second", нужно описать все условия (число валидаторов, их гео-распределение, уровень packetloss и т.п.) и описать логику бенчмаркинга. В блокчейнах просто накатить транзакцию на внутреннюю БД не означает ее принятие консенсусом
* Если в блокчейне есть дополнительный **алгоритм обеспечения финальности** транзакций (EOS, Ethereum 2.0, парачейны Polkadot, использующие консенсус с финальностью **GRANDPA**), то временем обработки транзакции можно считать промежуток между тем, как узел "увидел" транзакцию и следующим финализированным блоком, куда эта транзакция была включена

**Метрики**, специфичные для блокчейн сетей:
* **Local TPS (Число обрабатываемых транзакций / Время их обработки)**
  * Число обработанных узлом транзакций и max/avg/min время их обработки на локальном узле очень удобно измерять, так как функции, выполняющие эту операцию, обычно явно выделены в коде
* **Local produced blocks amount (Число производимых блоков)**
  * Метрика показывает, какой валидатор сколько блоков произвел
* **Finality Block (Время финализации)**
  * В сетях с явно реализованой финальностью с точки зрения пользователя блокчейна, транзакция завершается не в тот момент, когда она принята узлом, а когда появился блок, который финализирует цепочку, в которой находится транзакция. Чтобы финализировать блок, валидаторы должны получить этот блок по p2p сети, и обменяться подписями друг с другом. Именно здесь и проверяется реальная скорость блокчейна

Остальные метрики обычно сильно зависят от типа консенсуса, поэтому представлять их в числе основных не очень правильно. В числе таких параметров, например: количество форков цепочки, их длина в блоках, заполняемость блоков транзакциями и т.п. По ним можно определить ситуации разделения сети или быстро локализовать проблемы конкретного валидатора.

Полезные ссылки:
* [Анатомия одной транзакции: что можно узнать с помощью Etherscan](https://tangem.com/ru/blog/post/the-anatomy-of-a-transaction/)
* [Что нам стоит блокчейн построить?](https://habr.com/ru/post/443282/)
* [Как измерять производительность блокчейн сетей. Основные метрики](https://habr.com/ru/post/473846/)
* [The Advantages and Disadvantages of the Blockchain Technology](https://www.researchgate.net/publication/330028734_The_Advantages_and_Disadvantages_of_the_Blockchain_Technology)

---
### 21. EVM, smart contracts
Определение EVM из официальной [документации](https://ethereum.org/en/developers/docs/evm/):  
* Физический экземпляр EVM нельзя описать так же, как можно было бы указать на облако или океанскую волну, но он существует как единое целое, поддерживаемое тысячами подключенных компьютеров, на которых работает клиент Ethereum.

Назначение EVM из официальной [документации](https://ethereum.org/en/developers/docs/evm/):
* Сам протокол Ethereum существует исключительно с целью поддержания непрерывной, беспрерывной и неизменяемой работы этого специального конечного автомата (про конечный автомат см. заметки ниже). Это среда, в которой живут все учетные записи Ethereum и смарт-контракты.

> В любом заданном блоке в цепочке Ethereum имеет одно и только одно "каноническое" состояние, и EVM - это то, что определяет правила для вычисления нового допустимого состояния от блока к блоку.

**Состояние Ethereum** - это большая структура данных, которая содержит не только все учетные записи и балансы, но и состояние машины, которое может меняться от блока к блоку в соответствии с заранее определенным набором правил и которое может выполнять произвольный машинный код. Конкретные правила изменения состояния от блока к блоку определяются EVM.

Долговременная память EVM содержит:
* PC - количество выполненных операций
* Gas - сколько газа осталось в блоке

Главное отличие сети Ethereum в умных-контрактах (есть транзакции, как в Биткоине, но и транзакции-контракты).

**Смарт-контракты (smart contracts)**
  * Это технология, которая, теоретически, позволяет заключать любое соглашение между участниками сети без посредника
    * Участники сети заключают договоренности между собой, прописывают условия сделки и ставят цифровые подписи. Обязательное выполнение этих договоренностей охраняется кодом, который содержится в блокчейне
  * Это по сути запрограммированные сделки (byte-code), которые выполняются при определенных условиях. Условиями может быть достижение по:
	  * времени
	  * объему денежных средств
	* Простыми словами, смарт-контракт работает как детерминированная программа.
    * Она выполняет определённые действия, когда соблюдены заданные условия
	* Несмотря на общепринятую терминологию, смарт-контракты не являются ни контрактами в юридическом смысле, ни "умными" (от англ. smart). Это всего лишь фрагменты кода, запущенного в распределенной системе (в блокчейне)
		
В сети Ethereum смарт-контракты отвечают за выполнение операций между пользователями (адресами). Любой адрес, не являющийся смарт-контрактом, называется **личным аккаунтом (EOA)**. Таким образом, смарт-контракты управляются программным кодом, а личные аккаунты - пользователями.

> Ниже заметки с лекции А.А. Капитонова:

**Блокчейн** можно воспринимать как **автомат состояний**. Каждый новый **блок** будет **триггером** для перехода блокчейна в новое состояние. Каждый последующий блок хранит хеш предыдущего блока. Блоки можно представить, как **список (stack) транзакций**. В каждой транзакции содержится **адрес** и **состояние аккаунта**. **Аккаунт** - это объект в мире состояний. Аккаунт содержит информацию о балансе и программный код для Эфировской ВМ (EVM). Каждый адрес связан с балансом.

На лекции говорили, что **EVM** - эфировская виртуальная машина (ВМ) может получать данные о предыдущем состоянии блокчейна и помещать их в следующее состояние. Похожа на [ВМ Java(JVM)](https://help.reg.ru/support/servery-vps/oblachnyye-servery/ustanovka-programmnogo-obespecheniya/virtualnaya-mashina-java), то есть работает одинаково на любом железе.

> **Ethereum** - это распределенный конечный автомат.

В сети Ethereum **аккаунты** бывают двух типов:
* **Человек**
  * Содержит:
    * nonce
    * баланс
  * Пара ключей
    * Приватный ключ - для подписи транзакции (каждая транзакция подписывается единожды)
    * Публичный ключ - для проверки транзакции
* **Смарт-контракт**
  * Содержит:
    * nonce
    * баланс
    * **хранение хеша**
    * **код хеша**
  * После deploy bite-кода Эфировская ВМ (EVM) дает ему адрес (sender address)

В Ethereum **транзакции** бывают двух типов:
1. Создание смарт-контракта на выпуск NFT
2. Как первое, но добавляем в контракт дополнительную информацию:
  * номер NFT
  * ссылку на IPFS

В Ethereum **сообщения** бывают двух типов:
* От одного человека другому
* От смарт-контракта человеку

В сети Ethereum есть два **представления кода**:
* byte-code - по сравнению с исходным кодом, удобным для создания и чтения человеком, байт-код — это компактное представление программы, уже прошедшей синтаксический и семантический анализ.
* opt-code - набор команд

> Каждый аккаунт хранит состояние блокчейна (расстояние между блоками).

Недавно произошел переход Ethereum на другой алгоритм консенсуса:
* С переходом на PoS майнеры стали получать только комиссию (нет выпуска новых токенов).

**Еще отличия Ethereum от Биткоина:**  
* Награда за майнинг блок - 2 эфира.
* Блоки в Ethereum майнятся 1 раз в 15 секунд.
* Механизм сжигания ликвидности, чтобы количество монет как-то уравновесить.
* **Газ**
  * (пояснение): можно сделать контракт, который будет ссылаться сам на себя (бесконечно вызывать сам себя) и выполнять бесконечную операцию.
  * При обращении к такому контракту он повесит всю сеть
  * Чтобы такого не произошло, был введен объем газа, который сжигается за каждое вычисление в сети Ethereum. (на каждый блок выделен определенный объем газа)
  * После того, как контракт сожжёт весь газ, прекратит исполнение и возьмет комиссию, потому что газ привязан к единице стоимости эфира - Gway (гига way)
  * Uncle --> Дополнительные вознаграждения, механизм сжигания эфира
* Нужно следить, когда насытится сеть Ethereum (в Биткоин тоже!): то есть при достижении определенного количества блоков, награда майнеру уменьшается
  * Но в сети Ethereum есть понятие Uncle (дядя), то есть когда блок вычислило несколько майнеров награда разделяется, в отличие от Биткоина, где награда начисляется одному.
    * Так происходит потому что в сети Ethereum все происходит быстрее!
    * Когда мы добавляем Uncle'ов, появляется неопределенность, может 2 анклов будет, может 3, количество дополнительно имитированных монет не совсем предсказуемо, поэтому вводится механизм сжигания эфира

---
### 22. Полнота по Тьюрингу EVM, прерывания EVM
Машина Тьюринга - это бесконечная лента, не имеющая ни начала, ни конца, поделённая на ячейки (вспомните фильм Игра в имитацию).

Машина Тьюринга позволяет выполнить любое преобразование, соответственно, вы можете реализовать на ней абсолютно любой алгоритм или функцию. То же самое относится и к языкам. Если с его помощью вы можете **реализовать любой заданный алгоритм** - он тьюринг-полный. Если в дело вступают ограничения синтаксиса или любые физические - не полный.

**Полнота по Тьюрингу (Turing-completeness, TC)** - это свойство системы при некотором простом представлении ввода и вывода **реализовать любую вычислимую функцию**.

Виртуальная машина Ethereum - это среда выполнения смарт-контрактов в Ethreum.

EVM является полным по Тьюрингу, так как его можно использовать для выполнения вычислений различной сложности. Это важно, поскольку он должен понимать соглашения, которые составляют смарт-контракты.  

Будучи полным по Тьюрингу, Ethereum способен понять и реализовать любое будущее соглашение, даже то, которое еще не было придумано. Это то, что отличает Ethereum от Биткойна, поскольку последний является неполным по Тьюрингу, что ограничивает его функциональность.

**Прерывание EVM** происходит при помощи **газа** - ресурса, который позволяет выполнять код в среде EVM, измеряемый в "gwei" (единица стоимости эфира).

Газ также служит цели по предотвращению выполнения вредоносных действий, таких как распределенные атаки типа "отказ в обслуживании" (DDoS). Хотя EVM может выполнять практически любые вычисления, трудно предсказать время выполнения каждой операции.

Хорошо спланированная вредоносная операция может выполняться бесконечно, в результате чего сеть теряет скудную вычислительную мощность и в конечном итоге выходит из строя. Плата за газ предотвращает эту проблему, заставляя злоумышленников платить за каждый шаг, выполненный в вычислительном процессе.

Кроме превышения лимита газа существуют также следующие ситуации прерывания исполнения:
* недопустимое место назначения перехода
* неверная инструкция
* переполнение стека

Полезные ссылки:
* [Наследие Тьюринга: машина, тест и полнота](https://gb.ru/posts/about_turing)

---
### 23. Параметры ERC20, примеры программного кода
**Токены** - это активы, которые создаются на базе уже **готового** блокчейна.

Токены используются для **доступа** к определенной инфраструктуре или сервисам (аналогия с **фишками казино**). Например, эфириум является токеном доступа к вычислительным мощностям EVM (Ethereum Virtual Machine).

Токены могут представлять практически все, что угодно в Ethereum:
* Очки репутации в онлайн-платформе
* Навыки персонажа в игре
* Лотерейные билеты
* Финансовые активы, такие как доля в компании
* Фиатная валюта, такая как доллар
* США унция золота

Для выпуска своего токена вам потребуется 2 инструмента:
* Среда разработки
  * **Remix IDE** - существует в версии для браузера
* Код смарт-контракта для выпуска токена
  * **Solidity** - язык, который используется для программирования эфировской виртуальной машины. Этот код, как и транзакция и информация про токены, помещается в блокчейн. Как только вы к нему обращаетесь, он начинает исполняться

* **ERC (Ethereum Request for Comments, Запрос Эфириума в ответ на комментарии)** - разновидность технических документов, которые описывают **стандарт** программирования в этом блокчейне.

**ERC-20** - это технический стандарт, используемый для выпуска и реализации **токенов** на блокчейне Ethereum.
* ERC-20 реализует **API для токенов** в рамках смарт-контрактов.

Каждый новый токен ERC-20 (был вскоре заменён более эффективным EIP-20) автоматически получает **право взаимодействовать** с сервисами и программным обеспечением, соответствующим стандарту ERC-20.

Пример **функциональных возможностей**, которые предоставляет ERC-20:
* **transfer / transferFrom** - переводить токены с одной учетной записи на другую
* **balanceOf** - получать текущий баланс токенов учетной записи
* **totalSupply** - получать общий запас токенов, доступных в сети
* **approve** - ограничить количество токенов, которые смарт-контракт сможет снять с вашего баланса

Токены ERC-20 **не хранятся** в аккаунтах. Они существуют только внутри контракта, который представляет собой своеобразную автономную базу данных. Контракт определяет условия для токенов (например, имя, символ, делимость). В нем также содержится список, где сопоставляются балансы пользователей с их адресами Ethereum.

Технология предполагает несколько параметров для заключения смарт-контрактов. Их них 6 считается обязательными, а 3 (`name`, `decimals`, `symbol`) – по усмотрению, но рекомендуются для соблюдения.

**Параметры** смарт-контракта для выпуска токена **стандарта ERC-20**:
* `balance` - количество токенов, которые будут на адресе, выпускающем токен
* `totalSupply` - общее количество выпускаемых токенов (возможно, они будут распеределяться между несколькими кошельками)
* `name` - название токена
* `decimals` - количество нулей будет стоять после запятой
  * Необходимо добавить тоже количество нулей, которое ввели в поле `decimals`, к показателям в строках `balance` и `totalSupply`
* `symbol` - набор символов (аббревиатура)

Функции, которые обязательно должны присутствовать в смарт-контракте токена:
* **totalSupply**
  * Показывает общее **количество токенов** в контракте
  * `function totalSupply() public view returns (uint256)`
* **balance0f**
  * Показывает **баланс** токенов адреса по запросу.
  * `function balanceOf(address _owner) public view returns (uint256 balance)`
* **transfer**
  * **Переводит** токены одного пользователя другому
  * Чтобы ее использовать, нужно указать адрес получателя и сумму перевода. Запускает событие (в нашем случае event transfer), что указывает блокчейну на необходимость включить ссылку на него.  Записывает данные в блокчейн
  * `function transfer(address _to, uint256 _value) public returns (bool success)`
* **transferFrom**
  * Более удобная **альтернатива функции transfer**, которая обеспечивает большую программируемость в децентрализованных приложениях. Также запускает событие (в нашем случае event transfer), что указывает блокчейну на необходимость включить ссылку на него
  * `function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)`
* **approve**
  * Позволяет **ограничить количество токенов**, которые смарт-контракт сможет снять с вашего баланса. В ее отсутствие возникает риск ненадлежащего использования контракта: кто-то может эксплуатировать его в своих целях или украсть все средства. Записывает данные в блокчейн
  * `function approve(address _spender, uint256 _value) public returns (bool success)`
* **allowance**
  * Требуется для того, чтобы **проверять наличие достаточного баланса** на конкретном адресе для отправки цифровых монет по другому адресу (approve и allowance - это функции, отвечающие за процесс верификации способов перемещения электронных монет)
  * `function allowance(address _owner, address _spender) public view returns (uint256 remaining)`

Комплекс указанных данных помогает провайдерам и биржам формировать базу кодов, которая будет единой и позволит взаимодействовать со всеми smart-контрактами ERC-20.

Если объединить все вышеперечисленные функции, мы получим контракт ERC-20. С его помощью можно запрашивать общее предложение токенов, проверять баланс, переводить средства и давать разрешения другим DApp-приложениям на управление токенами.

**Главное преимущество** токенов ERC-20 - **гибкость**. Используя их, вы также можете внедрять дополнительные функции и задавать определенные параметры в соответствии со своими потребностями.

Полезные ссылки:
* [ERC-20 Token standart](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
* [ERC 20](https://docs.openzeppelin.com/contracts/2.x/api/token/erc20)

---
<div id="question_24"></div>

### 24. Параметры ERC721, ERC1155, примеры программного кода

**NFT (non-fungible token, «невзаимозаменяемый токен»)**
* С технологией NFT вы наверняка знакомы, если хоть раз регистрировали свои права на имущество, например, на квартиру или машину. Факт того, что вы – владелец имущества – **записывается в государственном реестре**, а если вы свое имущество продаете, то эта запись переходит покупателю.
* Похожим образом работает NFT: он **содержит информацию о своем создателе**, и с передачей этого токена другому лицу, например, покупателю, информация об авторском праве переходит новому владельцу.

**ERC721, ERC1155** - cтандарты, которые используются в NFTs – несменяемых токенах. Особенно удачно они работают в ситуациях, когда необходимо токенизировать единственный в своём роде актив.

**ERC-721** - это стандарт невзаимозаменяемого токена (NFT), написанный на языке Solidity в блокчейне Ethereum. Стандарт ERC-721 был создан Уильямом Энтрикеном, Дитером Ширли, Джейкобом Эвансом и Натассией Сакс в 2018 году. 

По сути, **каждый токен ERC-721 уникален** и представляет собой один актив. Более того, это позволяет разработчикам создавать совершенно новую экосистему токенов на блокчейне Ethereum.

Стандарт ERC-721 структурно напоминает ERC-20. Хотя смарт-контракты обоих токенов имеют несколько схожие функции, некоторые функции ERC-721 различаются.

Вот наиболее характерные **особенности ERC-721**:
* Имя токена
  * Каждый токен ERC-721 имеет поле имени, которое указывает имя токена **для внешних приложений** или контрактов
* Право собственности
  * Стандарт ERC-721 имеет определенное поле функций, которое определяет право собственности на базовый токен и дает указания о том, как передать это право собственности
* Отслеживание токенов
  * Стандарт ERC-721 имеет функцию под названием «tokenOfOwnerByIndex», которое позволяет разработчикам отслеживать токены с помощью уникального идентификатора

Пример контракта:
```c
pragma solidity ^0.5.0;

import "@openzeppelin/contracts/token/ERC721/ERC721Full.sol";
import "@openzeppelin/contracts/drafts/Counters.sol";

contract GameItem is ERC721Full {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    constructor() ERC721Full("GameItem", "ITM") public {
    }
    function awardItem(address player, string memory tokenURI) public returns (uint256) {
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        _mint(player, newItemId);
        _setTokenURI(newItemId, tokenURI);
        return newItemId;
    }
}
```

**Стандарт ERC-1155** - улучшение одновременно и ERC-20, и ERC-721. Он позволяет **в одном и том же контракте** описывать как взаимозаменяемые, так и невзаимозаменяемые единицы.

Вот наиболее характерные **особенности ERC-1155**:
* Эффективный перевод
  * Стандарт ERC-1155 позволяет пользователям совершать массовые переводы токенов в рамках смарт-контракта
    * Пакетная передача: передача нескольких ресурсов за один вызов
    * Пакетный баланс: получите балансы нескольких активов за один вызов
    * Пакетное подтверждение: подтвердите все токены для адреса
* Несколько токенов в одном контракте
  * Каждый токен ERC-1155 описывает существование и работу как взаимозаменяемых, так и невзаимозаменяемых типов токенов
* Безопасная передача токенов
  * Стандарт токенов ERC-1155 включает функцию, которая проверяет, является ли транзакция действительной или нет
* Hooks
  * Хуки - это технология перехвата вызовов функций в чужих процессах
  * Функция hook возвращает предопределенное значение bytes4, когда смарт-контракт принимает передачу
* Поддержка NFT
  * Если источник только 1, то он рассматривается как NFT

Пример контракта:
```s
// contracts/GameItems.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

contract GameItems is ERC1155 {
    uint256 public constant GOLD = 0;
    uint256 public constant SILVER = 1;
    uint256 public constant THORS_HAMMER = 2;
    uint256 public constant SWORD = 3;
    uint256 public constant SHIELD = 4;

    constructor() public ERC1155("https://game.example/api/item/{id}.json") {
        _mint(msg.sender, GOLD, 10**18, "");
        _mint(msg.sender, SILVER, 10**27, "");
        _mint(msg.sender, THORS_HAMMER, 1, "");
        _mint(msg.sender, SWORD, 10**9, "");
        _mint(msg.sender, SHIELD, 10**9, "");
    }
}
```

Полезные ссылки:
* [ERC 721](https://docs.openzeppelin.com/contracts/2.x/api/token/erc721)
* [ERC-1155 MULTI-TOKEN STANDARD](https://ethereum.org/en/developers/docs/standards/tokens/erc-1155/)

---
## Дополнительные материалы

### Разница между IP-адресом и MAC-адресом
**MAC-адрес** - это физический адрес, **идентифицирующий** фактическое устройство в локальной сети.
* MAC - Media Access Control
* 48-битный (6 байт) шестнадцатеричный адрес
* Канальный (2) уровень сетевой модели OSI
* Записан на **сетевую интерфейсную карту (NIC)** устройства, поэтому его можно изменить, только заменив NIC

**IP-адрес** - это логический адрес, **характеризующий местоположение** вашего устройства в сети Интернет.
* IP - Internet Protocol
* Виды адреса (разные версии протокола):
    * IPv4 - это 32-битный (4 байта) адрес
    * IPv6 - это 128-битный (16 байт) адрес
* Сетевой (3) уровень сетевой модели OSI
* IP-адреса обычно предоставляются администратором сети или Интернет-провайдерами (ISP, Internet service provider)
* Люди редко используют IP номера адресов напрямую, вместо этого используют **DNS-имена**, которые приложение переводит в соответствующий номер

### Разница между TCP и UDP протоколами
TCP и UDP протоколы - основные протоколы Траспортного (4) уровня модели OSI.

**TCP (Transmission Control Protocol, протокол управления передачей)** - это протокол, который гарантирует доставку данных в корректном виде (например, с помощью контрольной суммы).
* Он жёстко следит за каждым битом информации, но работает гораздо медленнее UDP.
* Используется например, при авторизации - нам важно передать последовательность символов в правильном порядке.
* TCP-пакет намного сложнее, чем UDP

**UDP (User Datagram Protocol, протокол пользовательских датаграмм)** - протокол, который не проверяет цельность битов, его задача - как можно быстрее передать данные с одного устройства на другое.
* Используется например, при передачи видео или аудио - там, где небольшие потери некритичны, зато важна скорость передачи данных.
* Несмотря на то, что UDP не гарантирует доставку, в нем помимо портов и IP есть поле контрольной суммы.

Полезные ссылки:
* [Что такое модель OSI и зачем она нужна: препарируем слоёный пирог интернета](https://skillbox.ru/media/code/chto-takoe-model-osi-i-zachem-ona-nuzhna-prepariruem-sloyenyy-pirog-interneta/)
* [Разница между IP-адресом и MAC-адресом](https://raznisa.ru/raznica-mezhdu-ip-adresom-i-mac-adresom/)
* [TCP против UDP или будущее сетевых протоколов](https://habr.com/ru/company/oleg-bunin/blog/461829/)

### vlan, vxlan, macvlan, veth
**vlan (Virtual Local Area Network, виртуальная локальная компьютерная сеть)** - группа устройств, имеющих возможность взаимодействовать между собой напрямую на Канальном (2) уровне, хотя физически при этом они могут быть подключены к разным сетевым коммутаторам.
* vlan основывается на работе протокола **802.1q**
* Используется для разделения подсетей
* В отличие от Ethernet-кадра 802.1q-кадр содержит **Тег**
* Самое популярное применение vlan-ов: логическое объединение узлов в группы независимо от их физического расположения, то есть изоляция одной группы узлов от другой. Очень удобно, когда сотрудники физически работают в разных местах, но должны быть объединены. И конечно с точки зрения безопасности vlan не заменимы. Главное, чтобы к сетевым устройствам имели доступ ограниченный круг лиц. Добились ограничения на Канальном (2) уровне.
* [Основы компьютерных сетей. Тема №6. Понятие VLAN, Trunk и протоколы VTP и DTP](https://habr.com/ru/post/319080/)

**vxlan (Virtual Extensible LAN, виртуальная расширяемая локальная сеть)** - это протокол туннелирования. Он решает проблему недостаточного количества идентификаторов vlan (всего 4096) при разделении крупномасштабных сетей.

**macvlan** - это, по сути, Linux switch, который основан на **статичном соответствии MAC и VLAN**. Здесь используется unicast-фильтрация, не promiscuous-режим. macvlan может работать в режиме private, VEPA, bridge, passthru. macvlan - это reverse VLAN в Linux. Данная технология позволяет взять один реальный интерфейс и сделать на его основе несколько виртуальных с разными MAC-адресами.

**veth (Виртуальный Ethernet)** - это локальный туннель Ethernet.

**Сетевой интерфейс** - физическое или виртуальное устройство, предназначенное для передачи данных между программами через компьютерную сеть.
* eth - сетевой интерфейс к карте Ethernet или картам WaveLan (Radio Ethernet).
* wlan - сетевой интерфейс wi-fi адаптеров